<!DOCTYPE html>
<html lang="zh-Hans">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    #map {
      width: 800px;
      height: 500px;
      background-color: #abc;
      position: relative;
      /* 因为子元素的位置是随机的，需要用到定位 所以 父盒子应配合 */
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <!-- <script src="food.js"></script>
  <script>
  // 1.先给一个地图 把范围确定好
  // 2.食物的属性：
  // 水平位置 垂直位置 宽度 高度 颜色 方法：render
  // 2.1 通过面向对象的方式来创建食物对象：
  // 2.1.1 先创建一个构造函数
  
  // 2.2.1 获取到地图map的DOM对象
  var map = document.getElementById('map');
  // 创建Food实例对象

  var food = new Food();

    //因为render方法中 依赖于地图DOM对象 为了更好的封装
  // 我们将地图DOM对象 作为render方法的参数
  // 这样处理后  food.js中的代码就不需要改动了
  // 只需要在使用render方法的时候 将地图DOM对象 作为参数
  // 传给render方法即可

  food.render(map);
  



  
  </script> -->

  <script>
    var map = document.getElementById('map');
    function Food(options) {
      options = options || {};
      this.x = options.x || 0;
      this.y = options.y || 0;
      this.width = options.width || 20;
      this.height = options.height || 20;
      this.bgColor = options.bgColor || '#963';

    }

    Food.prototype.render = function () {
      var foodElement = document.createElement('div');
      foodElement.style.width = this.width + 'px';
      foodElement.style.height = this.height + 'px';
      foodElement.style.backgroundColor = this.bgColor;
      this.x = parseInt(Math.random() * (map.offsetWidth / this.width));
      this.y = parseInt(Math.random() * (map.offsetHeight / this.height));
      foodElement.style.position = 'absolute';
      foodElement.style.left = this.x * this.width + 'px';
      foodElement.style.top = this.y * this.height + 'px';
      map.appendChild(foodElement);
    }

    var food = new Food({ bgColor: '#f6f' });
    food.render();
    console.log(food);


    function Snake(options) {
      options = options || {};
      this.width = options.width || 20;
      this.height = options.height || 20;
      this.headColor = options.headColor || '#66f';
      this.bodyColor = options.bodyColor || '#6f6';
      
      this.direction = options.direction || 'right';
      //确定蛇往哪个方向
      this.body = [{ x: 2, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 0 }];
    }
    

    Snake.prototype.render = function (target){
      for(var i = 0; i < this.body.length; i++){
        var span = document.createElement('span');
        span.style.width = this.width + 'px';
        span.style.height = this.height + 'px';
        span.style.backgroundColor = (i === 0) ?this.headColor:this.bodyColor;
        span.style.position = 'absolute';
        span.style.left = this.body[i].x * this.width + 'px';
        span.style.top = this.body[i].y * this.height + 'px';
        target.appendChild(span);
      }
    }
    
    // 先在第一节之前添加一个新的节, 然后, 将最后一项删除
    //    以 往右走 为例: 应该创建一个新的 { x: 第一节的x+1, y }
    Snake.prototype.move = function (target){
      // 我们先将 新节的坐标 设置为当前蛇头的坐标
      var newNode = {
        x:this.body[0].x,
        y:this.body[0].y
      }
      switch (this.direction) {
        case 'right':
          newNode.x++;
          break;
        case 'left':
          newNode.x--;
          break;
        case 'up':
          newNode.y--;
          break;
        case 'down':
          newNode.y++;
          break;
      }
      this.body.unshift(newNode);
      //将新节添加到第一个位置
      this.body.pop()
      //将最后一节 从body中删除

      // 重新根据最新的位置 渲染蛇
      this.render(target);
      // 注意: 每次重新渲染蛇的时候, 都需要先将原来蛇节对应的span元素, 从页面中删除
    }
    
    var snake = new Snake();
    snake.render(map);
    
    setInterval(function(){
      snake.move(map)
    },500)


  </script>

</body>

</html>